from dataclasses import dataclass
from datetime import datetime
from abc import ABC, abstractmethod
from abc import ABC, abstractmethod
from typing import List, Optional

@dataclass(frozen=True)
class MarketDataPoint:
    """Class for keeping track of an item in inventory."""
    timestamp: datetime
    symbol: str
    price: float
    daily_volume: Optional[float] = None

# Immutable dataclass: represents a trading signal generated by a strategy
@dataclass(frozen=True)
class Signal:
    timestamp: datetime   # when the signal was generated
    symbol: str           # stock symbol
    side: str             # "BUY" or "SELL"
    quantity: int         # quantity of shares to trade
    reason: str = ""      # optional text explaining why the signal was created
    strategy: str = "Unknown"  # strategy that generated this signal


class Strategy(ABC):
    def __init__(self, symbol: str, capital: float):
        self._symbol = symbol
        self._remaining_capital = capital
        self._current_position = {'quantity': 0, 'avg_price': 0.0}  # Track current position

    @abstractmethod
    def generate_signals(self, tick: MarketDataPoint, max_order_vol: float) -> List[Signal]:
        """
        Given a new MarketDataPoint, decide whether to emit trading signals.
        Returns a list (could be empty, or contain 1+ Signal objects).
        """
        pass
    
    @property
    def remaining_capital(self):
        return self._remaining_capital

    @remaining_capital.setter
    def remaining_capital(self, value: float):
        if value < 0:
            raise ValueError("Remaining capital cannot be negative")
        self._remaining_capital = value


class Order:
    def __init__(self, symbol: str, quantity: int, price: float, status: str):
        # Validate order parameters
        if not symbol or not isinstance(symbol, str):
            raise OrderError("Symbol must be a non-empty string")
        if quantity <= 0:
            raise OrderError(f"Quantity must be positive, got: {quantity}")
        if price <= 0:
            raise OrderError(f"Price must be positive, got: {price}")
        if not status or not isinstance(status, str):
            raise OrderError("Status must be a non-empty string")
            
        self._symbol = symbol
        self._quantity = quantity
        self._price = price
        self._status = status

    # setter and getter 
    @property
    def symbol(self):
        return self._symbol
    @property
    def quantity(self):
        return self._quantity
    @property
    def price(self):
        return self._price
    @property
    def status(self):
        return self._status
    @status.setter
    def status(self, value):
        self._status = value


class OrderError(Exception):
    """Raised when an order has invalid parameters"""
    pass

class ExecutionError(Exception):
    """Raised when order execution fails"""
    pass

